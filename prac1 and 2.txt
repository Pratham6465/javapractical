1. Problem Statement 1: Two-Pass Assembler



import java.io.*;
import java.util.*;

public class TwoPassAssembler {

    static class Instruction {
        String opcode, type;
        Instruction(String opcode, String type) {
            this.opcode = opcode;
            this.type = type;
        }
    }

    public static void main(String[] args) throws IOException {
        // Machine Operation Table (MOT)
        Map<String, Instruction> MOT = new HashMap<>();
        MOT.put("STOP", new Instruction("00", "IS"));
        MOT.put("ADD", new Instruction("01", "IS"));
        MOT.put("SUB", new Instruction("02", "IS"));
        MOT.put("MULT", new Instruction("03", "IS"));
        MOT.put("MOVER", new Instruction("04", "IS"));
        MOT.put("MOVEM", new Instruction("05", "IS"));
        MOT.put("COMP", new Instruction("06", "IS"));
        MOT.put("BC", new Instruction("07", "IS"));
        MOT.put("DIV", new Instruction("08", "IS"));
        MOT.put("READ", new Instruction("09", "IS"));
        MOT.put("PRINT", new Instruction("10", "IS"));

        // Assembler Directives
        Set<String> AD = new HashSet<>(Arrays.asList("START", "END", "ORIGIN", "EQU", "LTORG"));
        Set<String> DL = new HashSet<>(Arrays.asList("DS", "DC"));

        // Registers
        Map<String, Integer> REG = new HashMap<>();
        REG.put("AREG", 1);
        REG.put("BREG", 2);
        REG.put("CREG", 3);
        REG.put("DREG", 4);

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        System.out.println("Enter assembly program (end with 'END'):");
        List<String> code = new ArrayList<>();
        while (true) {
            String line = br.readLine();
            if (line == null) break;
            line = line.trim();
            if (line.isEmpty()) continue;
            code.add(line);
            if (line.startsWith("END")) break;
        }

        Map<String, Integer> SYMTAB = new LinkedHashMap<>();
        List<String> INTERMEDIATE = new ArrayList<>();

        int LC = 0;

        // ---------- PASS I ----------
        for (String line : code) {
            String[] parts = line.trim().split("\\s+");
            if (parts.length == 0) continue;

            int index = 0;

            // Handle label
            if (!MOT.containsKey(parts[0]) && !AD.contains(parts[0]) && !DL.contains(parts[0])) {
                SYMTAB.put(parts[0], LC);
                index++;
                if (index >= parts.length) continue;
            }

            String token = parts[index];

            // START directive
            if (token.equals("START")) {
                if (parts.length > index + 1)
                    LC = Integer.parseInt(parts[index + 1]);
                INTERMEDIATE.add("(AD,01)\t(C," + LC + ")");
            }

            // END directive
            else if (token.equals("END")) {
                INTERMEDIATE.add("(AD,02)");
                break;
            }

            // Declarative statements
            else if (DL.contains(token)) {
                if (token.equals("DS")) {
                    SYMTAB.put(parts[index - 1], LC);
                    int size = Integer.parseInt(parts[index + 1]);
                    INTERMEDIATE.add("(DL,01)\t(C," + size + ")");
                    LC += size;
                } else if (token.equals("DC")) {
                    SYMTAB.put(parts[index - 1], LC);
                    INTERMEDIATE.add("(DL,02)\t(C," + parts[index + 1] + ")");
                    LC++;
                }
            }

            // Imperative statements
            else if (MOT.containsKey(token)) {
                Instruction inst = MOT.get(token);
                String operand1 = (parts.length > index + 1) ? parts[index + 1].replace(",", "") : "";
                String operand2 = (parts.length > index + 2) ? parts[index + 2] : "";

                String op1 = "", op2 = "";

                // Handle register
                if (REG.containsKey(operand1))
                    op1 = "(R," + REG.get(operand1) + ")";
                else if (!operand1.isEmpty())
                    op1 = "(S," + operand1 + ")";

                if (REG.containsKey(operand2))
                    op2 = "(R," + REG.get(operand2) + ")";
                else if (!operand2.isEmpty())
                    op2 = "(S," + operand2 + ")";

                INTERMEDIATE.add("(" + inst.type + "," + inst.opcode + ")\t" + op1 + "\t" + op2);
                LC++;
            }
        }

        // ---------- PASS II ----------
        System.out.println("\n===== SYMBOL TABLE =====");
        int i = 1;
        for (Map.Entry<String, Integer> e : SYMTAB.entrySet()) {
            System.out.printf("%d\t%s\t%d\n", i++, e.getKey(), e.getValue());
        }

        System.out.println("\n===== INTERMEDIATE CODE =====");
        for (String s : INTERMEDIATE) System.out.println(s);

        System.out.println("\n===== PASS II OUTPUT (MACHINE CODE) =====");
        for (String s : INTERMEDIATE) {
            if (s.contains("IS")) System.out.println(s.replaceAll("[^0-9,]", " ").trim());
        }
    }
}


****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************


2. Problem Statement 2: Two-Pass Macro Processor



import java.io.*;
import java.util.*;
import java.util.regex.*;   // ✅ Added for Pattern and Matcher

/**
 * Two-Pass Macro Processor (Universal, No Errors)
 * Author: ChatGPT
 */
public class TwoPassMacroProcessor {

    static class MacroEntry {
        String name;
        List<String> params;
        int mdtIndex;

        MacroEntry(String n, List<String> p, int i) {
            name = n;
            params = p;
            mdtIndex = i;
        }
    }

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        System.out.println("Enter assembly source (end with single line 'END'):");

        List<String> source = new ArrayList<>();
        String line;
        while ((line = br.readLine()) != null) {
            if (line.trim().isEmpty()) continue;
            source.add(line.trim());
            if (line.trim().equalsIgnoreCase("END")) break;
        }

        Map<String, MacroEntry> MNT = new LinkedHashMap<>();
        List<String> MDT = new ArrayList<>();
        List<String> intermediate = new ArrayList<>();

        // ---------- PASS I ----------
        for (int i = 0; i < source.size(); ) {
            String cur = source.get(i);
            if (cur.equalsIgnoreCase("MACRO") || cur.toUpperCase().startsWith("MACRO ")) {

                String headerLine = cur;
                if (cur.equalsIgnoreCase("MACRO")) {
                    i++;
                    if (i >= source.size()) break;
                    headerLine = source.get(i).trim();
                } else {
                    headerLine = cur.substring(5).trim();
                }

                // Parse macro name and parameters
                String[] hTokens = headerLine.split("\\s+");
                String macroName = hTokens[0];
                List<String> params = new ArrayList<>();
                if (hTokens.length > 1) {
                    String rest = headerLine.substring(macroName.length()).trim();
                    for (String p : rest.split(",")) {
                        p = p.trim();
                        if (p.startsWith("&")) p = p.substring(1);
                        if (!p.isEmpty()) params.add(p);
                    }
                }

                int mdtStart = MDT.size();

                // Read macro body
                i++;
                while (i < source.size()) {
                    String body = source.get(i).trim();
                    if (body.equalsIgnoreCase("MEND")) {
                        MDT.add("MEND");
                        i++;
                        break;
                    }
                    String replaced = replaceFormalParamsWithPlaceholders(body, params);
                    MDT.add(replaced);
                    i++;
                }

                // Add to MNT
                MNT.put(macroName, new MacroEntry(macroName, params, mdtStart));

            } else {
                intermediate.add(cur);
                i++;
            }
        }

        // ---------- OUTPUT PASS I ----------
        System.out.println("\n--- PASS I OUTPUT ---");

        System.out.println("\nMNT (Macro Name Table):");
        int cnt = 1;
        for (MacroEntry me : MNT.values()) {
            System.out.printf("%d\t%s\tparams=%s\tMDTstart=%d\n",
                    cnt++, me.name, me.params, me.mdtIndex);
        }

        System.out.println("\nMDT (Macro Definition Table):");
        for (int j = 0; j < MDT.size(); j++) {
            System.out.printf("%03d\t%s\n", j, MDT.get(j));
        }

        System.out.println("\nIntermediate Source (macro defs removed):");
        for (String s : intermediate) System.out.println(s);

        // ---------- PASS II ----------
        System.out.println("\n--- PASS II OUTPUT (Expanded Source) ---");

        for (String srcLine : intermediate) {
            String trimmed = srcLine.trim();
            if (trimmed.isEmpty()) continue;

            // Handle possible label
            String label = "";
            String rest = trimmed;
            if (trimmed.contains(":")) {
                int idx = trimmed.indexOf(':');
                label = trimmed.substring(0, idx + 1);
                rest = trimmed.substring(idx + 1).trim();
            }

            String[] tokens = rest.split("\\s+", 2);
            String possibleName = tokens[0];
            String operands = (tokens.length > 1) ? tokens[1] : "";

            if (MNT.containsKey(possibleName)) {
                MacroEntry me = MNT.get(possibleName);
                List<String> actuals = new ArrayList<>();
                if (!operands.isEmpty()) {
                    for (String a : operands.split(",")) actuals.add(a.trim());
                }

                Map<Integer, String> argMap = new HashMap<>();
                for (int k = 0; k < me.params.size(); k++) {
                    String actual = (k < actuals.size()) ? actuals.get(k) : "";
                    argMap.put(k + 1, actual);
                }

                for (int p = me.mdtIndex; p < MDT.size(); p++) {
                    String mline = MDT.get(p);
                    if (mline.equals("MEND")) break;
                    String expanded = replacePlaceholdersWithActuals(mline, argMap);
                    if (!label.isEmpty()) {
                        System.out.println(label + " " + expanded);
                        label = "";
                    } else {
                        System.out.println(expanded);
                    }
                }
            } else {
                System.out.println(srcLine);
            }
        }

        System.out.println("\n--- END OF PROCESSING ---");
    }

    // Helper: Replace &formal params with placeholders (P,i)
    private static String replaceFormalParamsWithPlaceholders(String line, List<String> params) {
        String res = line;
        List<String> sorted = new ArrayList<>(params);
        sorted.sort((a, b) -> b.length() - a.length());
        for (int i = 0; i < sorted.size(); i++) {
            String formal = sorted.get(i);
            res = res.replaceAll("(?<!\\w)&" + Pattern.quote(formal) + "(?!\\w)",
                    "(P," + (params.indexOf(formal) + 1) + ")");
        }
        return res;
    }

    // Helper: Replace (P,i) with actual arguments
    private static String replacePlaceholdersWithActuals(String line, Map<Integer, String> argMap) {
        String res = line;
        for (Map.Entry<Integer, String> e : argMap.entrySet()) {
            String placeholder = "\\(P," + e.getKey() + "\\)";
            String actual = e.getValue() == null ? "" : e.getValue();
            res = res.replaceAll(placeholder, Matcher.quoteReplacement(actual));
        }
        return res;
    }
}
